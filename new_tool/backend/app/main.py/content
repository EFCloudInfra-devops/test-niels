from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from typing import Dict, Any
import asyncio, json
from .config import DEVICES, settings
from .schemas import ConfigureRequest, DeviceInterfaces, RollbackResponse
from .utils import generate_interfaces, validate_payload, is_sfp
from .models import save_desired, load_desired, add_audit, list_audits
from .netconf import (connect, get_device_interfaces_actual,
                      build_access_vlan_config, build_trunk_config,
                      build_poe_config, build_speed_duplex,
                      edit_and_commit, rollback_last)

app = FastAPI(title='Juniper Switch UI API', version='0.1.0')
app.add_middleware(CORSMiddleware, allow_origins=['*'], allow_credentials=True, allow_methods=['*'], allow_headers=['*'])

ACTUAL_STATE: Dict[str, Dict[str, Any]] = {}

async def periodic_sync():
    while True:
        for name, dev in DEVICES.items():
            try:
                interfaces = generate_interfaces(dev.vc_members)
                with connect(dev.mgmt_ip) as mgr:
                    actual = get_device_interfaces_actual(mgr, interfaces)
                ACTUAL_STATE[name] = actual
            except Exception as e:
                ACTUAL_STATE[name] = {'error': str(e)}
        await asyncio.sleep(settings.sync_interval_seconds)

@app.on_event('startup')
async def on_startup():
    asyncio.create_task(periodic_sync())

@app.get('/devices')
async def devices():
    return {'devices': [d.model_dump() for d in DEVICES.values()]}

@app.get('/devices/{device}/interfaces', response_model=DeviceInterfaces)
async def device_interfaces(device: str):
    if device not in DEVICES: raise HTTPException(404, 'device not found')
    desired_raw = load_desired(device)
    desired = {k: json.loads(v) for k,v in desired_raw.items()} if desired_raw else {}
    actual = ACTUAL_STATE.get(device, {})
    drift = {}
    for ifn, dval in desired.items():
        aval = actual.get(ifn)
        drift[ifn] = {'changed': True if aval else False, 'desired': dval, 'actual': aval}
    return DeviceInterfaces(device=device, desired=desired, actual=actual, drift=drift)

@app.post('/devices/{device}/interfaces/{ifname}/configure')
async def configure_interface(device: str, ifname: str, req: ConfigureRequest):
    if device not in DEVICES: raise HTTPException(404, 'device not found')
    dev = DEVICES[device]
    payload = req.changes.model_dump()
    errs = validate_payload(ifname, payload)
    if errs: raise HTTPException(400, '; '.join(errs))

    save_desired(device, ifname, json.dumps(payload))

    confs = []
    mode = payload.get('mode'); poe = payload.get('poe'); sd = payload.get('speed_duplex')
    if mode:
        if mode.get('mode') == 'access':
            confs.append(build_access_vlan_config(ifname, int(mode.get('access_vlan'))))
        elif mode.get('mode') == 'trunk':
            confs.append(build_trunk_config(ifname, [int(v) for v in (mode.get('trunk_vlans') or [])], mode.get('native_vlan_id')))
    if poe:
        if is_sfp(ifname): raise HTTPException(400, 'PoE not allowed on SFP+')
        confs.append(build_poe_config(ifname, bool(poe.get('enable'))))
    if sd:
        confs.append(build_speed_duplex(ifname, sd.get('speed'), sd.get('auto_negotiation'), sd.get('link_mode')))

    diff_joined = ''; status = 'success'
    try:
        with connect(dev.mgmt_ip) as mgr:
            if confs:
                from lxml import etree
                root_conf = etree.Element('configuration')
                for c in confs:
                    for el in c:
                        root_conf.append(el)
                diff_txt = edit_and_commit(mgr, root_conf)
                diff_joined = diff_txt
    except Exception as e:
        status = f'error: {e}'
    add_audit(req.user, device, ifname, 'configure', status, '', '', diff_joined)
    return {'status': status, 'diff': diff_joined}

@app.post('/devices/{device}/sync')
async def sync_device(device: str):
    if device not in DEVICES: raise HTTPException(404, 'device not found')
    dev = DEVICES[device]
    try:
        interfaces = generate_interfaces(dev.vc_members)
        with connect(dev.mgmt_ip) as mgr:
            actual = get_device_interfaces_actual(mgr, interfaces)
        ACTUAL_STATE[device] = actual
        return {'status': 'ok', 'count': len(actual)}
    except Exception as e:
        raise HTTPException(500, f'sync failed: {e}')

@app.post('/devices/{device}/rollback', response_model=RollbackResponse)
async def rollback_device(device: str):
    if device not in DEVICES: raise HTTPException(404, 'device not found')
    dev = DEVICES[device]
    try:
        with connect(dev.mgmt_ip) as mgr:
            rollback_last(mgr)
        add_audit('system', device, '*', 'rollback', 'success')
        return RollbackResponse(device=device, status='success')
    except Exception as e:
        add_audit('system', device, '*', 'rollback', f'error: {e}')
        raise HTTPException(500, f'rollback failed: {e}')

@app.get('/audits')
async def audits(limit: int = 100):
    return {'audits': list_audits(limit)}
